<html>
<head>
<title>6.837 Assignment 1</title>
</head>

<body background="../../images/blbkgnd.gif" bgcolor="#FFFFFF" text="#000000">
<h1>6.837 Intro to Computer Graphics<br>
Assignment 1: Ray Casting</h1>

<p>
In this assignment, you will implement a basic ray caster. This will
be the basis of many future assignments, so proper code design is
quite important. As seen in class, a ray caster sends a ray for each
pixel and intersects it with all the objects in the scene. You will
implement a ray caster for an orthographic camera (parallel rays) for
sphere primitives. You will use a very basic shading model: the
objects have a constant color. You will also implement a visualization
mode to display the distance <em>t</em> of each pixel to the
camera.

<p>
You will use object-oriented design to make your ray-caster flexible
and extendable. A generic <tt>Object3D</tt> class will serve as the
parent class for all 3D primitives. You will derive subclasses, such
as <tt>Sphere</tt>, to implement specialized primitives. In later
assignments, you will extend the set of primitives with planes and
polygons.  Similarly, this assignment requires the implementation of a
general <tt>Camera</tt> class and an <tt>OrthographicCamera</tt>
subclass. In the next assignment, you will also derive a general
perspective camera.

<p>
We provide you with a <tt>Ray</tt> class and a <tt>Hit</tt> class to
manipulate camera rays and their intersection points, and a skeleton
<tt>Material</tt> class.

<h3>Tasks</h3>

<ul>

<p><li> Write a pure virtual <tt>Object3D</tt> class. It only provides
the specification for 3D primitives, and in particular the ability to
be intersected with a ray via the virtual method:

<pre>
   virtual bool intersect(const Ray &r, Hit &h, float tmin) = 0;
</pre>

<p> Since this method is pure virtual for the <tt>Object3D</tt> class,
the prototype in the header file includes '<tt>= 0;</tt>'.  Subclasses
derived from <tt>Object3D</tt> must implement this routine.  An
<tt>Object3D</tt> stores a pointer to its <tt>Material</tt> type.  For
this assignment, materials are very simple and consist of a single
color.  Your <tt>Object3D</tt> class must have:
<ul>
<li> a default constructor and destructor,
<li> a pointer to a <tt>Material</tt> instance, and
<li> a pure virtual intersection method.
</ul>
<p>

<p><li> Derive <tt>Sphere</tt>, a subclass of <tt>Object3D</tt>, that
additionally stores a center point and a radius.  The <tt>Sphere</tt>
constructor will be given the center, radius, and pointer to a
<tt>Material</tt> instance.  The <tt>Sphere</tt> class implements the
virtual <tt>intersect</tt> method mentioned above (but without the
'<tt>= 0;</tt>'):

<pre>
  virtual bool intersect(const Ray &r, Hit &h, float tmin);
</pre>

<p> 
With the <tt>intersect</tt> routine, we are looking for the closest
intersection along a <tt>Ray</tt>, parameterized by <em>t</em>.
<tt>tmin</tt> is used to restrict the range of intersection.  If an
intersection is found such that <em>t</em>  > <tt>tmin</tt> and
<em>t</em> is less than the value of the intersection currently
stored in the <tt>Hit</tt> data structure, <tt>Hit</tt> is updated as
necessary.  Note that if the new intersection is closer than the
previous one, both <tt>t</tt> and <tt>Material</tt> must be modified.
It is important that your intersection routine verifies that
<em>t</em> >= <tt>tmin</tt>.  <tt>tmin</tt> depends on the type of
camera (see below) and is not modified by the intersection routine.

<p><li> 

Derive <tt>Group</tt>, also a subclass of <tt>Object3D</tt>, that
stores an array of pointers to <tt>Object3D</tt> instances.  For
example, it will be used to store the entire 3D scene.  You'll need to
write the <tt>intersect</tt> method of <tt>Group</tt> which loops
through all these instances, calling their intersection methods.  The
<tt>Group</tt> constructor should take as input the number of objects
under the group. The group should include a method to add the objects:

<pre>
   void addObject(int index, Object3D *obj); 
</pre>

<p><li> Write a pure virtual <tt>Camera</tt> class and subclass
<tt>OrthographicCamera</tt>.  The <tt>Camera</tt> class has two pure
virtual methods:

<pre>
   virtual Ray generateRay(Vec2f point) = 0;
   virtual float getTMin() const = 0;
</pre>


The first is used to generate rays for each screen-space coordinate,
described as a <tt>Vec2f</tt>.  The direction of the rays generated by
an orthographic camera is always the same, but the origin varies.  The
<tt>getTMin()</tt> method will be useful when tracing rays through the
scene.  For an orthographic camera, rays always start at infinity, so
<tt>tmin</tt> will be a large negative value.  However, in the next
assignment you will implement a perspective camera and the value of
<tt>tmin</tt> will be zero to correctly clip objects behind the viewpoint.

<p>
<img src="ortho.png">

<p>
An orthographic camera is described by an orthonormal basis (one point
and three vectors) and an image size (one floating point).  The
constructor takes as input the center of the image, the direction
vector, an up vector, and the image size.  The input direction might
not be a unit vector and must be normalized. The input up vector might
not be a unit vector <em>or</em> perpendicular to the direction.  It
must be modified to be orthonormal to the direction.  The third basis
vector, the horizontal vector of the image plane, is deduced from the
direction and the up vector (hint: remember vector algebra and cross
products).  The origin of the rays generated by the camera for the
screen coordinates, which vary from <tt>(0,0) -> (1,1)</tt>, should
vary from:

<pre>
   center - (size*up)/2 - (size*horizontal)/2  ->  center + (size*up)/2 + (size*horizontal)/2
</pre>

<p>
The camera does not know about screen resolution.  Image resolution
should be handled in your main loop.  For non-square image ratios,
just crop the screen coordinates accordingly.
<p>

<p><li> Use the input file parsing code provided to load the camera,
  background color and objects of the scene.

<p><li> Write a main function that reads the scene (using the parsing
  code provided), loops over the pixels in the image plane, generates
  a ray using your <tt>OrthographicCamera</tt> class, intersects it
  with the high-level <tt>Group</tt> that stores the objects of the
  scene, and writes the color of the closest intersected object.

<p><li> Implement a second rendering style to visualize the depth
<em>t</em> of objects in the scene.  Two input depth values specify
the range of depth values which should be mapped to shades of gray in
the visualization.  Depth values outside this range are simply
clamped.

<p><li> Extra credit: Write both the geometric and algebraic sphere
intersection methods, add cylinders and cones, fog based on distance
to the image plane, etc.

</ul>

<h3>Ray, Hit & Material Classes</h3>

We provide the <tt>Ray</tt>, <tt>Hit</tt> & <tt>Material</tt> classes.
A <tt>Ray</tt> is represented by its origin and direction vectors.
The <tt>Hit</tt> class stores information about the closest
intersection point, the value of the ray parameter <em>t</em> and a
pointer to the <tt>Material</tt> of the object at the intersection.
The <tt>Hit</tt> data structure must be initialized with a very large
<em>t</em> value.  It is modified by the intersection computation to
store the new closest <em>t</em> and the <tt>Material</tt> of
intersected object.  For this assignment a <tt>Material</tt> stores
just the diffuse color of the object.  You will extend this class in
future assignments.

<ul>
<li><a href = "ray.h">ray.h</a>
<li><a href = "hit.h">hit.h</a>
<li><a href = "material.h">material.h</a>
</ul>

<h3>Parsing command line arguments & input files</h3>
  
Your program should take a number of command line arguments to specify
the input file, output image size and output file.  Make sure the
examples below work, as this is how we will test your program.  A
simple scene file parser for this assignment is provided.  The
<tt>OrthographicCamera</tt>, <tt>Group</tt> and <tt>Sphere</tt>
constructors and the <tt>Group::addObject</tt> method you will write
are called from the parser.  Look in the <tt>scene_parser.C</tt> file
for details.

<ul>
<li><a href = "parse_code.txt">parse_code.txt</a>
<li><a href = "scene_parser.h">scene_parser.h</a>
<li><a href = "scene_parser.C">scene_parser.C</a>
</ul>

If you're interested, here's the <a href = "grammar.html">scene
description file grammar</a> used in this assignment.

<h3>Hints</h3>
<ul>
<li> Use a small image size for faster debugging. <tt>64 x 64</tt> pixels is
  usually enough to realize that something might be wrong.
<li> As usual, don't hesitate to print as much information as needed
  for debugging, such as the direction vector of the rays, the hit
  values, etc.
<li> Use <tt>assert()</tt> to check function pre-conditions, array
  indices, etc.  See <tt>assert.h</tt>.
<li> The "very large" negative and positive values for <em>t</em> used in
  the <tt>Hit</tt> class and the <tt>intersect</tt> routine can simply be
  initialized with large values relative to the camera position and
  scene dimensions.  However, to be more correct, you can use the
  positive and negative values for infinity from the IEEE floating
  point standard (for extra credit).
</ul>

<h3>Additional References</h3>
<ul>
<li><a href="http://www.irtc.org/">http://www.irtc.org/</a>
<li><a href="http://www.acm.org/tog/resources/RTNews/html/">http://www.acm.org/tog/resources/RTNews/html/</a>
<li><a href="http://www.povray.org/">http://www.povray.org/</a>
<li><a href="http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace0.htm">http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace0.htm</a>
<li><a href="http://www.siggraph.org/education/materials/HyperGraph/raytrace/rt_java/raytrace.html">http://www.siggraph.org/education/materials/HyperGraph/raytrace/rt_java/raytrace.html</a>
</ul>



<h3>Input Files</h3>
<ul>
<li><a href = "scene1_01.txt">scene1_01.txt</a>
<li><a href = "scene1_02.txt">scene1_02.txt</a>
<li><a href = "scene1_03.txt">scene1_03.txt</a>
<li><a href = "scene1_04.txt">scene1_04.txt</a>
<li><a href = "scene1_05.txt">scene1_05.txt</a>
<li><a href = "scene1_06.txt">scene1_06.txt</a>
<li><a href = "scene1_07.txt">scene1_07.txt</a>
</ul>

<h3>Makefile for g++ on LINUX</h3>
<ul>
<li><a href = "Makefile">Makefile</a>
</ul>

<h3>Sample Results</h3>

<pre>
raytracer -input scene1_01.txt -size 200 200 -output output1_01.tga -depth 9 10 depth1_01.tga
</pre>
<p>
<img src="output1_01.png"> 
<img src="depth1_01.png"> 
<p>
<pre>
raytracer -input scene1_02.txt -size 200 200 -output output1_02.tga -depth 8 12 depth1_02.tga
</pre>
<p>
<img src="output1_02.png"> 
<img src="depth1_02.png"> 

<p>
<pre>
raytracer -input scene1_03.txt -size 200 200 -output output1_03.tga -depth 8 12 depth1_03.tga
</pre>
<p>
<img src="output1_03.png"> 
<img src="depth1_03.png"> 

<p>
<pre>
raytracer -input scene1_04.txt -size 200 200 -output output1_04.tga -depth 12 17 depth1_04.tga
</pre>
<p>
<img src="output1_04.png"> 
<img src="depth1_04.png"> 

<p>
<pre>
raytracer -input scene1_05.txt -size 200 200 -output output1_05.tga -depth 14.5 19.5 depth1_05.tga
</pre>
<p>
<img src="output1_05.png"> 
<img src="depth1_05.png"> 

<p>
<pre>
raytracer -input scene1_06.txt -size 200 200 -output output1_06.tga -depth 3 7 depth1_06.tga
</pre>
<p>
<img src="output1_06.png"> 
<img src="depth1_06.png"> 

<p>
<pre>
raytracer -input scene1_07.txt -size 200 200 -output output1_07.tga -depth -2 2 depth1_07.tga
</pre>
<p>
<img src="output1_07.png"> 
<img src="depth1_07.png"> 

<p>
See the main <a href="../index.html">Assignments Page</a> for submission information.
<hr>
</body>
</html>
